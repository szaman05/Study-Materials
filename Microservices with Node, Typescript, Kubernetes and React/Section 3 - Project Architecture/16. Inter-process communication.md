# Inter-Process Communication in Microservices

In this video, we explore the inter-process communication between microservices in our project. This involves how services communicate with each other using event-driven architecture.

## Communication Overview

- **Client to API Gateway**: Uses HTTP/HTTPS for request-response communication.
- **API Gateway to Microservices**: Also uses HTTP/HTTPS.
- **Microservices to Microservices**: Uses event-driven communication with RabbitMQ.

## Event-Driven Communication

### Notification Service
- **Receives Events**: From Auth, Order, and Chat services.
- **Sends Events**: None.

### Auth Service
- **Sends Events**: To Notification and User services.
- **Receives Events**: None.

### User Service
- **Sends Events**: To Gig service.
- **Receives Events**: From Auth, Order, Gig, and Review services.

### Gig Service
- **Sends Events**: To User service.
- **Receives Events**: From User service.

### Chat Service
- **Sends Events**: To Notification service.
- **Receives Events**: None.

### Order Service
- **Sends Events**: To User and Notification services.
- **Receives Events**: From Review service.

### Review Service
- **Sends Events**: To User and Order services.
- **Receives Events**: None.

## Implementation Details

- **RabbitMQ**: Used for event-driven communication.
  - **Producer**: Service that sends events.
  - **Consumer**: Service that receives events.

## Key Points

- No direct HTTP requests between microservices.
- Event-driven communication enhances decoupling and scalability.
- RabbitMQ is chosen for its reliability and ease of use.

For more details, watch the tutorial video: [Udemy Course Video](https://www.udemy.com/course/microservices-with-nodejs-react-typescript-and-kubernetes/learn/lecture/40860753)
